---
format: gfm
---

# networkmerge

A minimal example dataset was created with the ATIP tool.
The example dataset can be found in the `data` folder.

To read-in the data into Python we used the following:

``` python
import matplotlib.pyplot as plt
import pandas as pd
import math
from typing import List, Tuple
from shapely.geometry import LineString
import geopandas as gpd
import osmnx as ox

network = gpd.read_file("data/minimal-input.geojson")
# Column names:
network.columns
output = gpd.read_file("data/minimal-output.geojson")
network.plot(column='value')
plt.show()
output.plot(column='value')
plt.show()

# Download Leeds Road Network data from OSM
# Define the point and distance
point = (53.81524, -1.53880)
distance = 500  # in meters

#-----------------------------------------------------------------------#
#----Download the road network data for the area around the point-------#
#-----------------------------------------------------------------------#
graph = ox.graph_from_point(point, dist=distance, network_type='all')

# Save the road network as a shapefile
ox.save_graph_shapefile(graph, filepath=r'data/')

gdf = gpd.read_file("data/minimal-input.geojson")
gdf_road = gpd.read_file("data/edges.shp")

# Create the plot
fig, ax = plt.subplots(figsize=(10, 10))

# Plot the Shapefile data
gdf_road.plot(ax=ax, color='blue')

# Plot the GeoJSON data
gdf.plot(ax=ax, color='red')

plt.show()

#-----------------------------------------------------------------------#
#--------------Find matching lines from Leeds road data-----------------#
#-----------------------------------------------------------------------#

# Define the buffer size
buffer_size = 0.00001

# Create a buffer around the geometries in gdf
gdf_buffered = gdf.copy()
gdf_buffered.geometry = gdf.geometry.buffer(buffer_size)

# Initialize an empty DataFrame to store the matching lines
matching_lines_large_intersection = gpd.GeoDataFrame(columns=gdf_road.columns)

# Define the intersection length threshold
intersection_length_threshold = 0.0001

# Iterate over the buffered geometries in the GeoJSON GeoDataFrame
for geojson_line in gdf_buffered.geometry:
    # Iterate over the geometries in the shapefile GeoDataFrame
    for _, edge_row in gdf_road.iterrows():
        shapefile_line = edge_row.geometry
        
        # Calculate the intersection of the GeoJSON line and the shapefile line
        intersection = geojson_line.intersection(shapefile_line)
        
        # If the length of the intersection exceeds the threshold, add the shapefile line to the matching lines DataFrame
        if intersection.length > intersection_length_threshold:
            matching_lines_large_intersection = pd.concat([matching_lines_large_intersection, pd.DataFrame(edge_row).T])

# Plot gdf_buffered (in blue) and matching_lines_buffered (in green) on the same plot
fig, ax = plt.subplots(figsize=(10, 10))

gdf_buffered.boundary.plot(ax=ax, color='blue', label='minimal-input.geojson (Buffered)')
matching_lines_large_intersection.plot(ax=ax, color='green', label='matching_lines_buffered')
gdf.plot(ax=ax, color='black')
ax.set_title('Comparison of minimal-input.geojson (Buffered) and matching_lines_buffered')
ax.legend()

plt.show()

#---------------------------------------------------------------------------------------#
#-----------------------------Function to split line by angle---------------------------#
#---------------------------------------------------------------------------------------#
def split_line_at_angles(line, threshold=30):
    if isinstance(line, LineString):
        coords = np.array(line.coords)
    elif isinstance(line, MultiLineString):
        coords = np.concatenate([np.array(geom.coords) for geom in line.geoms])
    else:
        raise ValueError(f"Unexpected geometry type: {type(line)}")

    # Compute the direction of each vector
    vectors = np.diff(coords, axis=0)
    directions = np.arctan2(vectors[:,1], vectors[:,0])

    # Compute the angle between each pair of vectors
    angles = np.diff(directions)
    
    # Convert the angles to degrees and take absolute values
    angles = np.abs(np.degrees(angles))

    # Identify the indices where the angle exceeds the threshold
    split_indices = np.where(angles > threshold)[0] + 1

    # Split the line at the points corresponding to the split indices
    segments = []
    last_index = 0
    for index in split_indices:
        segment = LineString(coords[last_index:index+1])
        segments.append(segment)
        last_index = index
    segment = LineString(coords[last_index:])
    segments.append(segment)

    return segments
# Apply the function to each line in the gdf with threshold=30
gdf_split = gdf['geometry'].apply(lambda x: split_line_at_angles(x, threshold=30))
gdf_split = gdf_split.explode().reset_index(drop=True)
gdf_split = gpd.GeoDataFrame(geometry=gdf_split)
gdf_split.crs = gdf.crs

# Plot the gdf_split
fig, ax = plt.subplots(figsize=(10, 10))
gdf_split.plot(ax=ax)

# Add labels for each line with its index
for x, y, label in zip(gdf_split.geometry.centroid.x, gdf_split.geometry.centroid.y, gdf_split.index):
    ax.text(x, y, str(label), fontsize=12)

plt.show()

#---------------------------------------------------------------------------------------#
#Function to find the nearest line in the Shapefile for a given line in the GeoJSON file#
#---------------------------------------------------------------------------------------#
def find_nearest_line(line, lines_df, geom_col='geometry'):
    # Calculate the distance from the line to all lines in the Shapefile
    distances = lines_df[geom_col].distance(line)
    
    # Find the index of the line with the shortest distance
    idx_min = distances.idxmin()
    
    # Return the row with the shortest distance
    return lines_df.loc[idx_min]

# Apply the function to each line in the GeoJSON file
nearest_lines = gdf_split['geometry'].apply(find_nearest_line, lines_df=gdf_road)

# Now we have a DataFrame with the nearest line from the Shapefile for each line in the GeoJSON file
nearest_lines[['name', 'highway']]
nearest_lines['value'] = gdf_split['value']
gdf_att = nearest_lines[['name', 'highway', 'value','geometry']]
gdf_att = gpd.GeoDataFrame(gdf_att, geometry='geometry')
gdf_att.to_file("data/gdf_att.geojson", driver='GeoJSON')
#--------------------------------------------------------------#
#-----Function to find the lines have same start_end point-----#
#--------------------------------------------------------------#
def check_same_start_end(gdf, line1, line2):
    """
    Check if two lines have the same start and end points.
    
    """
    line1_start_end = (gdf.iloc[line1].geometry.coords[0], gdf.iloc[line1].geometry.coords[-1])
    line2_start_end = (gdf.iloc[line2].geometry.coords[0], gdf.iloc[line2].geometry.coords[-1])

    same_start = line1_start_end[0] == line2_start_end[0]
    same_end = line1_start_end[1] == line2_start_end[1]

    return same_start, same_end

check_same_start_end(geo_data, 0, 1)


# Add the value of Line 0 to Line 1
gdf_att.loc[1, 'value'] += gdf_att.loc[0, 'value']

# Remove Line 0
gdf_att = gdf_att.drop(0)

# Reset the index
gdf_att = gdf_att.reset_index(drop=True)

gdf_att.plot()

#--------------------------------------------------------------#
#-----Function to find the lines have same start_end point-----#
#--------------------------------------------------------------#
```

```{r}
#| eval: false
#| echo: false
# Create input dataset:
network = sf::read_sf("data/minimal-example-2-scotthall-road.geojson")
network$description = as.numeric(network$description)
network = network["description"]
network$value = c(1, 2)
network = stplanr::overline(network, attrib = "value")
network
sf::write_sf(network, "data/minimal-input.geojson")
plot(network[1, "value"])
plot(network[2, "value"])
network_merged = network
network_merged$value[2] = network_merged$value[1] + network_merged$value[2]
network_merged = network_merged[-1, ]
plot(network_merged)
sf::write_sf(network_merged, "data/minimal-output.geojson")
```
