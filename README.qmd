---
format: gfm
---

# networkmerge

A minimal example dataset was created with the ATIP tool.
The example dataset can be found in the `data` folder.

To read-in the data into Python we used the following:

``` python
import matplotlib.pyplot as plt
import pandas as pd
import math
from typing import List, Tuple
from shapely.geometry import LineString
import geopandas as gpd
import osmnx as ox

network = gpd.read_file("data/minimal-input.geojson")
# Column names:
network.columns
output = gpd.read_file("data/minimal-output.geojson")
network.plot(column='value')
plt.show()
output.plot(column='value')
plt.show()

# Download Leeds Road Network data from OSM
# Define the point and distance
point = (53.81524, -1.53880)
distance = 500  # in meters

#-----------------------------------------------------------------------#
#------------function to plot GeoDataFrame with index label-------------#
#-----------------------------------------------------------------------#
def plot_geodataframe_with_labels(gdf):
    """
    Plot a GeoDataFrame with labels for each line with its index.

    Args:
    gdf (geopandas.GeoDataFrame): The GeoDataFrame to plot.

    Returns:
    None
    """
    # Create a new figure
    fig, ax = plt.subplots(figsize=(10, 10))

    # Plot the GeoDataFrame
    gdf.plot(ax=ax)

    # Add labels for each line with its index
    for x, y, label in zip(gdf.geometry.centroid.x, gdf.geometry.centroid.y, gdf.index):
        ax.text(x, y, str(label), fontsize=12)

    # Display the plot
    plt.show()

#-----------------------------------------------------------------------#
#----Download the road network data for the area around the point-------#
#-----------------------------------------------------------------------#
graph = ox.graph_from_point(point, dist=distance, network_type='all')

# Save the road network as a shapefile
ox.save_graph_shapefile(graph, filepath=r'data/')

gdf = gpd.read_file("data/minimal-input.geojson")
gdf_road = gpd.read_file("data/edges.shp")

# Create the plot
fig, ax = plt.subplots(figsize=(10, 10))

# Plot the Shapefile data
gdf_road.plot(ax=ax, color='blue')

# Plot the GeoJSON data
gdf.plot(ax=ax, color='red')

plt.show()

#-----------------------------------------------------------------------#
#--------------Find matching lines from Leeds road data-----------------#
#-----------------------------------------------------------------------#

# Define the buffer size
buffer_size = 0.00001

# Create a buffer around the geometries in gdf
gdf_buffered = gdf.copy()
gdf_buffered.geometry = gdf.geometry.buffer(buffer_size)

# Initialize an empty DataFrame to store the matching lines
matching_lines_large_intersection = gpd.GeoDataFrame(columns=gdf_road.columns)

# Define the intersection length threshold
intersection_length_threshold = 0.0001

# Iterate over the buffered geometries in the GeoJSON GeoDataFrame
for geojson_line in gdf_buffered.geometry:
    # Iterate over the geometries in the shapefile GeoDataFrame
    for _, edge_row in gdf_road.iterrows():
        shapefile_line = edge_row.geometry
        
        # Calculate the intersection of the GeoJSON line and the shapefile line
        intersection = geojson_line.intersection(shapefile_line)
        
        # If the length of the intersection exceeds the threshold, add the shapefile line to the matching lines DataFrame
        if intersection.length > intersection_length_threshold:
            matching_lines_large_intersection = pd.concat([matching_lines_large_intersection, pd.DataFrame(edge_row).T])

# Plot gdf_buffered (in blue) and matching_lines_buffered (in green) on the same plot
fig, ax = plt.subplots(figsize=(10, 10))

gdf_buffered.boundary.plot(ax=ax, color='blue', label='minimal-input.geojson (Buffered)')
matching_lines_large_intersection.plot(ax=ax, color='green', label='matching_lines_buffered')
gdf.plot(ax=ax, color='black')
ax.set_title('Comparison of minimal-input.geojson (Buffered) and matching_lines_buffered')
ax.legend()

plt.show()

#---------------------------------------------------------------------------------------#
#-----------------------------Function to split line by angle---------------------------#
#---------------------------------------------------------------------------------------#
def split_line_at_angles(line, value, threshold=30):
    if isinstance(line, LineString):
        coords = np.array(line.coords)
    elif isinstance(line, MultiLineString):
        coords = np.concatenate([np.array(geom.coords) for geom in line.geoms])
    else:
        raise ValueError(f"Unexpected geometry type: {type(line)}")

    # Compute the direction of each vector
    vectors = np.diff(coords, axis=0)
    directions = np.arctan2(vectors[:,1], vectors[:,0])

    # Compute the angle between each pair of vectors
    angles = np.diff(directions)
    
    # Convert the angles to degrees and take absolute values
    angles = np.abs(np.degrees(angles))

    # Identify the indices where the angle exceeds the threshold
    split_indices = np.where(angles > threshold)[0] + 1

    # Split the line at the points corresponding to the split indices
    segments = []
    last_index = 0
    for index in split_indices:
        segment = LineString(coords[last_index:index+1])
        segments.append((segment, value))
        last_index = index
    segment = LineString(coords[last_index:])
    segments.append((segment, value))

    return segments

# Apply the function to each line in the gdf with threshold=30
gdf_split_list = gdf.apply(lambda row: split_line_at_angles(row['geometry'], row['value'], threshold=30), axis=1)

# Convert the list of tuples into a DataFrame
gdf_split = pd.DataFrame([t for sublist in gdf_split_list for t in sublist], columns=['geometry', 'value'])

# Convert the DataFrame to a GeoDataFrame
gdf_split = gpd.GeoDataFrame(gdf_split, geometry='geometry')

# Set the CRS of gdf_split to match that of gdf
gdf_split.crs = gdf.crs

# Plot the gdf_split
fig, ax = plt.subplots(figsize=(10, 10))
gdf_split.plot(ax=ax)

# Add labels for each line with its index
for x, y, label in zip(gdf_split.geometry.centroid.x, gdf_split.geometry.centroid.y, gdf_split.index):
    ax.text(x, y, str(label), fontsize=12)

plt.show()

#---------------------------------------------------------------------------------------#
#Function to find the nearest line in the Shapefile for a given line in the GeoJSON file#
#---------------------------------------------------------------------------------------#
def get_nearest_line_attributes(line, gdf):
    # Calculate the centroid of the line
    line_centroid = line.centroid
    
    # Calculate the distances from the line's centroid to the centroids of all lines in the GeoDataFrame
    distances = gdf.centroid.distance(line_centroid)
    
    # Get the index of the line with the minimum distance
    min_distance_index = distances.idxmin()
    
    # Return the attributes of the nearest line
    return gdf.loc[min_distance_index]

# Initialize a list to store the attributes of the nearest lines
nearest_lines_attributes = []

# Iterate through the lines in gdf_split
for line in gdf_split.geometry:
    # Get the attributes of the nearest line in gdf_road
    nearest_line_attributes = get_nearest_line_attributes(line, gdf_road)
    # Append the attributes to the list
    nearest_lines_attributes.append(nearest_line_attributes)

# Convert the list of Series to a DataFrame
nearest_lines_attributes = pd.concat(nearest_lines_attributes, axis=1).T

# Reset the index of the DataFrame
nearest_lines_attributes.reset_index(drop=True, inplace=True)

# Rename the 'geometry' column in nearest_lines_attributes to 'geometry_road'
nearest_lines_attributes.rename(columns={'geometry': 'geometry_road'}, inplace=True)

# Concatenate gdf_split and nearest_lines_attributes
gdf_split = pd.concat([gdf_split.reset_index(drop=True), nearest_lines_attributes.reset_index(drop=True)], axis=1)

gdf_att gdf_split[['geometry', 'value', 'name', 'highway','ref']] 

# Plot the data
fig, ax = plt.subplots(figsize=(10, 10))
gdf_att.plot(ax=ax)

# Add labels for each line with its index
for x, y, label in zip(gdf_att.geometry.centroid.x, gdf_att.geometry.centroid.y, gdf_att.index):
    ax.text(x, y, str(label), fontsize=12)

plt.show()

#--------------------------------------------------------------#
#-----Function to find the lines have same start_end point-----#
#--------------------------------------------------------------#
def check_same_start_end(gdf, line1, line2):
    """
    Check if two lines have the same start and end points.
    
    """
    line1_start_end = (gdf.iloc[line1].geometry.coords[0], gdf.iloc[line1].geometry.coords[-1])
    line2_start_end = (gdf.iloc[line2].geometry.coords[0], gdf.iloc[line2].geometry.coords[-1])

    same_start = line1_start_end[0] == line2_start_end[0]
    same_end = line1_start_end[1] == line2_start_end[1]

    return same_start, same_end

check_same_start_end(geo_data, 0, 1)


# Add the value of Line 0 to Line 1
gdf_att.loc[1, 'value'] += gdf_att.loc[0, 'value']

# Remove Line 0
gdf_att = gdf_att.drop(0)

# Reset the index
gdf_att = gdf_att.reset_index(drop=True)

gdf_att.plot()

#--------------------------------------------------------------#
#-----Function to find the lines have same start_end point-----#
#--------------------------------------------------------------#
```

```{r}
#| eval: false
#| echo: false
# Create input dataset:
network = sf::read_sf("data/minimal-example-2-scotthall-road.geojson")
network$description = as.numeric(network$description)
network = network["description"]
network$value = c(1, 2)
network = stplanr::overline(network, attrib = "value")
network
sf::write_sf(network, "data/minimal-input.geojson")
plot(network[1, "value"])
plot(network[2, "value"])
network_merged = network
network_merged$value[2] = network_merged$value[1] + network_merged$value[2]
network_merged = network_merged[-1, ]
plot(network_merged)
sf::write_sf(network_merged, "data/minimal-output.geojson")
```
