---
format: gfm
---

# Prerequisites

To run the code in this repo, you need to have a working Python installation with the following packages installed (with pip in this case):

```{bash}
#| eval: false
pip install matplotlib pandas shapely geopandas osmnx networkx scipy folium mapclassify
```


# networkmerge

A minimal example dataset was created with the ATIP tool.
The example dataset can be found in the `data` folder.

To read-in the data into Python we used the following:

```{python}
#| label: Import necessary library and all defined functions:calculate_total_length, plot_geodataframe_with_labels, plot_geodataframes, filter_data, create_buffer, get_vector, calculate_angle, split_line_at_angles, calculate_segment_angle, filter_parallel_lines_concat, calculate_distance


import matplotlib.pyplot as plt
import pandas as pd
import math
from typing import List, Tuple
from shapely.geometry import LineString
import geopandas as gpd
import osmnx as ox
import numpy as np
from scipy.spatial.distance import pdist, squareform
from shapely.geometry import Point, LineString, Polygon, MultiLineString
import networkx as nx
from pyproj import CRS
import folium
import os
from numpy.linalg import norm
from collections import defaultdict

# Calculate total length of linestrings in a GeoDataFrame 
def calculate_total_length(gdf, crs="EPSG:32630"):
    # Copy the GeoDataFrame
    gdf_projected = gdf.copy()

    # Change the CRS to a UTM zone for more accurate length calculation
    gdf_projected = gdf_projected.to_crs(crs)

    # Calculate the length of each line
    gdf_projected["length"] = gdf_projected.length

    # Calculate the total length
    total_length = gdf_projected["length"].sum()

    return total_length

# Plot GeoDataFrame and label each feature with its index
def plot_geodataframe_with_labels(gdf, gdf_name):

    # Create a new figure
    fig, ax = plt.subplots(figsize=(10, 10))

    # Plot the GeoDataFrame
    gdf.plot(ax=ax)

    # Add labels for each line with its index
    for x, y, label in zip(gdf.geometry.centroid.x, gdf.geometry.centroid.y, gdf.index):
        ax.text(x, y, str(label), fontsize=12)
    plt.savefig(f"pics/{gdf_name}.jpg")
    # Display the plot
    plt.show()

# Create interactive map from one or more GeoDataFrames  
def plot_geodataframes(*args, colors=['red', 'blue', 'green'], line_widths=[3.5, 2.5,1.5], marker_sizes=[10, 10, 10], map_type="OpenStreetMap"):
    """
    Args:
        *args: One or more (name, GeoDataFrame) tuples 
        colors: List of colors for lines
        line_widths: List of line widths
        map_type: Folium map type
    Returns:
        Folium map object
    """
    # Prepare gdfs and their names
    gdfs = [arg[1] for arg in args]
    names = [arg[0] for arg in args]

    # Initialize the map to the first point of the first geodataframe
    start_point = gdfs[0].iloc[0].geometry.centroid.coords[0]
    m = folium.Map(location=[start_point[1], start_point[0]], zoom_start=15)

    if map_type == "Esri Satellite":
        esri = folium.TileLayer(
            tiles="https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
            attr="Esri",
            name="Esri Satellite",
            control=True
        )
        esri.add_to(m)

    # Create feature groups for each geodataframe and add them to the map
    for i, gdf in enumerate(gdfs):
        fg = folium.FeatureGroup(name=names[i], show=False)
        for _, row in gdf.iterrows():
            if row.geometry.geom_type == 'Point':
                marker = folium.Marker(location=[row.geometry.y, row.geometry.x], 
                                       icon=folium.Icon(color=colors[i % len(colors)]))
                fg.add_child(marker)
            elif row.geometry.geom_type == 'LineString':
                line = folium.vector_layers.PolyLine(locations=[[p[1], p[0]] for p in list(row.geometry.coords)],
                                                      color=colors[i % len(colors)],
                                                      weight=line_widths[i % len(line_widths)])
                fg.add_child(line)
            elif row.geometry.geom_type == 'Polygon':
                polygon = folium.vector_layers.Polygon(locations=[[p[1], p[0]] for p in list(row.geometry.exterior.coords)],
                                                       color=colors[i % len(colors)],
                                                       fill=True)
                fg.add_child(polygon)

            elif row.geometry.geom_type == 'MultiLineString':
                coordinates = [list(p) for line in row.geometry.geoms for p in line.coords]
                line = folium.vector_layers.PolyLine(locations=[[p[1], p[0]] for p in coordinates],
                                                    color=colors[i % len(colors)],
                                                    weight=line_widths[i % len(line_widths)])
                fg.add_child(line)
        m.add_child(fg)

    # Add layer control to the map
    folium.LayerControl().add_to(m)

    return m

# Filter GeoDataFrame based on column conditions  
def filter_data(gdf, conditions):
    """
    Filter a GeoDataFrame based on multiple conditions.

    """
    for column, condition in conditions.items():
        gdf = gdf[condition(gdf[column])]
    return gdf

# Buffer input geometries by specified distance
def create_buffer(gdf, buffer_size = 0.00002):
    gdf_buffered = gdf.copy()
    gdf_buffered.geometry = gdf.geometry.buffer(buffer_size)
    # gdf_buffered.to_file("data/gdf_buffered.geojson", driver='GeoJSON')
    return  gdf_buffered

# Get start and end points from (Multi)LineString  
def get_vector(line):
    if isinstance(line, LineString):
        start, end = line.coords[:2]
    else:  # for MultiLineStrings, just use the first line
        start, end = line.geoms[0].coords[:2]
    return [end[0] - start[0], end[1] - start[1]]

# Calculate angle between two vectors 
def calculate_angle(vector1, vector2):
    dot_product = vector1[0] * vector2[0] + vector1[1] * vector2[1]
    magnitude_product = math.sqrt(vector1[0]**2 + vector1[1]**2) * math.sqrt(vector2[0]**2 + vector2[1]**2)
    cos_angle = dot_product / magnitude_product
    angle = math.degrees(math.acos(cos_angle))
    return angle

# Modified function to split a line into segments based on an angle threshold
# and retain the 'value', 'Quietness', and original index
def split_line_at_angles(line, value, quietness, original_index, threshold=30):
    segments = []
    if isinstance(line, LineString):
        coords = np.array(line.coords)
        # Compute the direction of each vector
        vectors = np.diff(coords, axis=0)
        directions = np.arctan2(vectors[:, 1], vectors[:, 0])
        # Compute the angle between each pair of vectors
        angles = np.diff(directions)
        # Convert the angles to degrees and take absolute values
        angles = np.abs(np.degrees(angles))
        # Identify the indices where the angle exceeds the threshold
        split_indices = np.where(angles > threshold)[0] + 1
        # Split the line at the points corresponding to the split indices
        last_index = 0
        for index in split_indices:
            segment = LineString(coords[last_index:index + 1])
            segments.append((segment, value, quietness, original_index))
            last_index = index
        # Include all remaining parts of the line after the last split point
        segment = LineString(coords[last_index:])
        segments.append((segment, value, quietness, original_index))
    elif isinstance(line, MultiLineString):
        # Handle each LineString in the MultiLineString separately
        for geom in line.geoms:
            segments.extend(split_line_at_angles(geom, value, quietness, original_index, threshold))
    else:
        raise ValueError(f"Unexpected geometry type: {type(line)}")

    return segments

# Calculate angle between two line segments 
def calculate_angle(line1, line2):
    # Define the vectors
    vector1 = np.array(line1[1]) - np.array(line1[0])
    vector2 = np.array(line2[1]) - np.array(line2[0])
    
    # Compute the dot product
    dot_product = np.dot(vector1, vector2)
    
    # Compute the magnitudes of the vectors
    magnitude1 = np.sqrt(np.dot(vector1, vector1))
    magnitude2 = np.sqrt(np.dot(vector2, vector2))
    
    # Compute the angle between the vectors in radians
    angle_rad = np.arccos(dot_product / (magnitude1 * magnitude2))
    
    # Convert the angle to degrees
    angle_deg = np.degrees(angle_rad)
    
    return angle_deg

# Concat parallel linestrings into single geometry
def filter_parallel_lines_concat(gdf, name, angle_tolerance=25):
    # Filter the GeoDataFrame by the 'name' column
    filtered_gdf = gdf[gdf['name'] == name]

    # Create a list to store the parallel lines
    parallel_lines = []

    # Iterate through each pair of lines
    for i in range(len(filtered_gdf)):
        for j in range(i+1, len(filtered_gdf)):
            # Get the lines
            line1 = list(filtered_gdf.iloc[i].geometry.coords)
            line2 = list(filtered_gdf.iloc[j].geometry.coords)

            # Calculate the angle between the lines
            angle = calculate_angle(line1, line2)

            # If the angle is close to 0 or 180 degrees, add the lines to the list
            if abs(angle) <= angle_tolerance or abs(angle - 180) <= angle_tolerance:
                parallel_lines.append(filtered_gdf.iloc[i:i+1])
                parallel_lines.append(filtered_gdf.iloc[j:j+1])

    # Combine the lines into a new GeoDataFrame using pd.concat
    parallel_gdf = pd.concat(parallel_lines).drop_duplicates()

    return parallel_gdf

# Distance between two points
def calculate_distance(point1, point2):
    return Point(point1).distance(Point(point2))

# !!! Create a function to sum the values and record the index
def process_sjoin_result(sjoin_result):
    sjoin_result['value_sum'] = 0
    sjoin_result['Line_index_from_gdf'] = None
    for idx, row in sjoin_result.iterrows():
        idx_line = row['index_left']
        value = gdf.loc[idx_line, 'commute_fastest_bicycle_go_dutch']
        sjoin_result.loc[idx, 'value_sum'] += value
        if sjoin_result.loc[idx, 'Line_index_from_gdf'] is None:
            sjoin_result.loc[idx, 'Line_index_from_gdf'] = str(idx_line)
        else:
            sjoin_result.loc[idx, 'Line_index_from_gdf'] += "," + str(idx_line)
    sjoin_result['Line_index_from_gdf'] = sjoin_result['Line_index_from_gdf'].astype(str)
    return sjoin_result    

def plot_buffer_with_lines(gdf_buffered, gdf, buffer_index='all', relation='intersect'):
    # Determine the column to use based on the relation (within or intersect)
    column_name = 'Line_index_from_gdf_Within' if relation == 'within' else 'Line_index_from_gdf_Intersect'

    # Create a figure and axis
    fig, ax = plt.subplots(figsize=(12, 8))

    # Function to plot a single buffer with lines
    def plot_single_buffer(buffer_idx, buffered_geom):
        # Extract the indices of lines based on the relation
        indices_related_buffer = buffered_geom[column_name]

        # Plot the buffered geometry
        gpd.GeoSeries([buffered_geom['geometry']]).plot(ax=ax, edgecolor='blue', facecolor='none')

        # Check if there are any related lines and plot them
        if indices_related_buffer:
            gdf.loc[indices_related_buffer].plot(ax=ax, color='red')
            # Annotate the lines related to the buffer with their indices
            for idx in indices_related_buffer:
                plt.annotate(text=idx, xy=gdf.loc[idx, 'geometry'].centroid.coords[0], fontsize=9, color='red')
        else:
            plt.annotate(text="No lines " + relation, xy=buffered_geom['geometry'].centroid.coords[0], fontsize=9, color='blue')

        # Annotate the buffer with its index, placed below the buffer to avoid overlap
        plt.annotate(text=f"Buffer Index: {buffer_idx}", xy=(buffered_geom['geometry'].centroid.x, buffered_geom['geometry'].centroid.y - 0.00015), fontsize=9, color='blue', ha='center')

    if buffer_index == 'all':
        # Iterate through the buffered geometries
        for buffer_idx, buffered_geom in gdf_buffered.iterrows():
            plot_single_buffer(buffer_idx, buffered_geom)
        plt.title(f'Buffered Geometries (Blue) with {relation.capitalize()} Lines (Red)')
    elif isinstance(buffer_index, int):
        # Plot the buffered geometry for the specified index
        plot_single_buffer(buffer_index, gdf_buffered.loc[buffer_index])
        plt.title(f'Buffered Geometry (Blue) with {relation.capitalize()} Lines (Red) for Buffer Index {buffer_index}')

    plt.xlabel('Longitude')
    plt.ylabel('Latitude')
    plt.show()

```

```{python}
#| label: Download the road network for Area-of-Interest and read GeoJSON files

# Define the centre point of AoT and distance
point = (55.952227 , -3.1959271)
distance = 1300  # in meters

# Only download if the data/edges.shp file does not exist:
if not os.path.exists("data/edges.shp"):
    # Download the road network data
    graph = ox.graph_from_point(point, dist=distance, network_type='all')

    # Save the road network as a shapefile
    ox.save_graph_shapefile(graph, filepath=r'data/')

# Read in data from CycleStreets + overline
gdf = gpd.read_file("data/rnet_princes_street.geojson")
gdf.shape
gdf = gdf.rename(columns={'commute_fastest_bicycle_go_dutch': 'value'})
gdf['value'].sum()

# Checking if the 'value' and 'Quietness' columns are present in gdf
if 'value' in gdf.columns and 'Quietness' in gdf.columns:
    # Using the dissolve method to merge the lines based on 'value' and 'Quietness'
    # This will also include individual lines that can't be dissolved
    gdf_dissolved_and_individual = gdf.dissolve(by=['value', 'Quietness'])

    # Calculating the length of the lines (both merged and individual)
    gdf_dissolved_and_individual['length'] = gdf_dissolved_and_individual['geometry'].length

    # Resetting the index
    gdf_dissolved_and_individual.reset_index(inplace=True)
gdf_dissolved_and_individual['value'].sum()
gdf = gdf_dissolved_and_individual
gdf.shape

# Applying the split function to the gdf GeoDataFrame
segments_list_modified = []
for index, row in gdf.iterrows():
    segments = split_line_at_angles(row['geometry'], row['value'], row['Quietness'], index)
    segments_list_modified.extend(segments)

# Creating a new GeoDataFrame with the individual segments and additional attributes
segments_gdf_modified = gpd.GeoDataFrame(segments_list_modified, columns=['geometry', 'value', 'Quietness', 'Ori_index'])
segments_gdf_modified['value'].sum(), segments_gdf_modified.shape, segments_gdf_modified.head()
segments_gdf_modified.shape

# gdf_dissolved_and_individual.to_file("data/gdf_dissolved_and_individual.geojson", driver='GeoJSON')
# # Filter the data with conditions
# conditions = {
#     'value': lambda x: x != 0
# }

# filtered_gdf = filter_data(gdf, conditions)

# Read in simplified road nextwork data 
# gdf_road = gpd.read_file("data/edges.shp")
# gdf_road_simplified = gpd.read_file("data/NT_RoadLink.shp")
gdf_road_simplified = gpd.read_file("data/Edc_Roadlink.geojson")
gdf_road_simplified.explore()
# gdf_road_simplified = gdf_road_simplified.rename(columns={'name1': 'name'})
gdf_road_simplified = gdf_road_simplified[['identifier', 'geometry']]
gdf_road_simplified.crs = "EPSG:4326"
 
# # Filter the data with conditions
# conditions = {
#     'name': lambda x: x.notnull(),
#     'class': lambda x: ~x.isin(['Unclassified', 'Unknown']),
#     # 'primary': lambda x: ~x.isin(['false'])
# }

# filtered_gdf_road_simplified = filter_data(gdf_road_simplified, conditions)

# filtered_gdf_road_simplified = filtered_gdf_road_simplified.to_crs(epsg=4326)

# Plotting the geodataframes
map = plot_geodataframes(('gdf', gdf), ('gdf_road_simplified', gdf_road_simplified),
                          colors=['blue', 'red', 'green'], line_widths=(3.0, 1.0, 1.5), map_type="Esri Satellite")
map

# Use the function to calculate the total length
total_length = calculate_total_length(gdf)
total_length
# TODO: check total length after network simplification
total_distance_traveled = round(sum(gdf['value'] * gdf['length']))
total_distance_traveled
```

```{r}
#| eval: false
gdf = sf::read_sf("data/rnet_princes_street.geojson")
gdf_road = sf::read_sf("data/edges.shp")
library(tmap)
tmap_mode("view")
m = tm_shape(gdf_road) +
  tm_lines("blue", lwd = 9) +
  tm_shape(gdf) +
  tm_lines("red", lwd = 3) 
dir.create("maps")
tmap_save(m, "maps/edinburgh.html")
browseURL("maps/edinburgh.html")
```

```{bash}
#| eval: false
#| echo: false
# Upload edinburgh.html as a release with gh tool to the v0.1 release:
gh release list
gh release upload v0.1 maps/edinburgh.html
```

```{python}
#| label: Join attribute (commute_fastest_bicycle_go_dutch) from gdf to gdf_road_simplified
#| eval: false
gdf = segments_gdf_modified

# Step 1: Create a buffer around the geometries in gdf_road_simplified
gdf_buffered = create_buffer(gdf_road_simplified, buffer_size=0.00022)

# Step 2.1: identifying all lines in gdf that are within the buffer
# Initializing the required columns
gdf_buffered['value_sum'] = 0
gdf_buffered['Line_index_from_gdf_Within'] = None
all_lines_within_buffer = []

# Iterate through the buffered geometries to find lines within the buffer and sum their 'value'
for buffer_index, buffered_geom in gdf_buffered.iterrows():
    # Dictionary to store lines grouped by 'Ori_index'
    lines_by_ori_index = defaultdict(list)
    
    # Find lines within the buffer and group them by 'Ori_index'
    indices_within_buffer = []
    for line_index, line_geom in gdf.iterrows():
        if line_geom['geometry'].within(buffered_geom['geometry']):
            lines_by_ori_index[line_geom['Ori_index']].append(line_geom['value'])
            indices_within_buffer.append(line_index)
    
    # Calculate the mean value for each group and add to 'value_sum'
    value_sum = 0
    for ori_index, values in lines_by_ori_index.items():
        mean_value = sum(values) / len(values)
        value_sum += mean_value
        
    gdf_buffered.at[buffer_index, 'value_sum'] = value_sum
    gdf_buffered.at[buffer_index, 'Line_index_from_gdf_Within'] = indices_within_buffer
    all_lines_within_buffer.extend(indices_within_buffer)

plot_buffer_with_lines(gdf_buffered, gdf, buffer_index=1477, relation='within')
gdf_buffered.iloc[752]['value_sum']
# Step 2.2: identifying all lines in gdf that intersect with the buffer
gdf_buffered['Line_index_from_gdf_Intersect'] = None
for buffer_index, buffered_geom in gdf_buffered.iterrows():
    indices_intersecting_buffer = []  # Indices of lines intersecting with the buffer
    value_sum = gdf_buffered.loc[buffer_index, 'value_sum']  # Existing value_sum for the buffer
    corresponding_road_line = gdf_road_simplified.loc[buffer_index]['geometry']  # Corresponding road line
    for line_index, line_geom in gdf.iterrows():
        # Skip lines that are already within any buffer
        if line_index in all_lines_within_buffer:
            continue
        if line_geom['geometry'].intersects(buffered_geom['geometry']):
            vector1 = get_vector(line_geom['geometry'])
            vector2 = get_vector(corresponding_road_line)
            angle = calculate_angle(vector1, vector2)
            if angle < 25:
                value_sum += line_geom['value']
            indices_intersecting_buffer.append(line_index)
    gdf_buffered.at[buffer_index, 'value_sum'] = value_sum
    gdf_buffered.at[buffer_index, 'Line_index_from_gdf_Intersect'] = indices_intersecting_buffer

plot_buffer_with_lines(gdf_buffered, gdf, buffer_index=1477, relation='intersect')
gdf_buffered.iloc[1477]['Line_index_from_gdf_Intersect']

# Displaying the first few rows of the updated gdf_buffered
gdf_buffered.head()

# Extracting the details for the provided example
example_buffer_index = 84
example_line_index_gdf = 83
example_line_index_road_simplified = 84

# Getting the geometries for the example
example_buffer_geom = gdf_buffered.loc[example_buffer_index]['geometry']
example_line_gdf = gdf.loc[example_line_index_gdf]['geometry']
example_line_road_simplified = gdf_road_simplified.loc[example_line_index_road_simplified]['geometry']

# Calculating the vector and angle for the example
vector_gdf = get_vector(example_line_gdf)
vector_road_simplified = get_vector(example_line_road_simplified)
example_angle = calculate_angle(vector_gdf, vector_road_simplified)

# Checking the condition for adding the 'value'
add_value_condition = example_angle < 25

# Getting the 'value_sum' and 'Line_index_from_gdf_Intersect' for the corresponding buffer
example_value_sum = gdf_buffered.loc[example_buffer_index]['value_sum']
example_line_indices_intersect = gdf_buffered.loc[example_buffer_index]['Line_index_from_gdf_Intersect']

example_angle, add_value_condition, example_value_sum, example_line_indices_intersect

# Step 3: Match the attributes from gdf_buffered to gdf_road_simplified using the index, and then update gdf_road_simplified with these attributes.
# Joining gdf_buffered with gdf_road_simplified on the index to combine attributes
gdf_road_simplified_updated = gdf_road_simplified.join(gdf_buffered[['value_sum', 'Line_index_from_gdf_Within', 'Line_index_from_gdf_Intersect']])

# Displaying the first few rows of the updated gdf_road_simplified DataFrame
gdf_road_simplified_updated.head()

