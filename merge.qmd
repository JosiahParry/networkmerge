---
format: gfm
---

# Prerequisites

..

```{r}
#| label: import library
library(tidyverse)
library(sf)
library(tmap)
```



```{r}
#| label: read input_complex and input_simple
input_complex = sf::read_sf("data/rnet_princes_street.geojson")
# input_simple = sf::read_sf("data/Edc_Roadlink.geojson")
# input_complex_union = sf::st_union(input_complex)
# input_complex_30m_buffer = sf::st_buffer(input_complex_union, 30)
# input_complex_convex_hull = sf::st_convex_hull(input_complex_union)
# input_simple = sf::st_intersection(input_simple, input_complex_convex_hull)
# sf::write_sf(input_simple, "data/rnet_pinces_street_simple.geojson")
# names(input_complex)[1] = "value"
# sf::write_sf(input_complex, "data/rnet_princes_street.geojson", delete_dsn = TRUE)
input_simple = sf::read_sf("data/rnet_pinces_street_simple.geojson")
```

```{r}
#| label: plotting spatial data using the tmap
m1 = qtm(input_complex)
m2 = qtm(input_simple)
tmap_arrange(m1, m2, nrow = 1)
```

```{r}
#| label: insatll stplanr
remotes::install_github("ropensci/stplanr")
# stplanr::rnet_join
```

The values in the `input_complex` dataset are as follows:

```{r}
#| label: summary of input_complex
names(input_complex)
summary(input_complex$value)
```

To join the network values we will try the `rnet_join` function in `stplanr`, which has the following arguments:

```{r}
#| label: obtain the arguments of the rnet_join function
args(stplanr::rnet_join)
```

```{r}
input_simple_id = input_simple |>
  select(identifier)

rnet_joined = stplanr::rnet_join(input_simple_id, input_complex, dist = 22)
rnet_joined
nrow(rnet_joined)
nrow(input_simple_id)
names(input_complex)
names(rnet_joined)

m1 = qtm(input_complex)
m2 = qtm(rnet_joined)
tmap_arrange(m1, m2, nrow = 1)
```

The overlapping network values are as follows:

```{r}
#| label: overlapping
tm_shape(rnet_joined) + tm_fill("value")
```

We can calculate the distance-weighted average of the network values as follows:

```{r}
summary(rnet_joined$length_y)
summary(rnet_joined$length)
rnet_joined_df = rnet_joined |>
  sf::st_drop_geometry() |>
  mutate(value_weighted = value * length_y)
total_d = sum(input_complex$length * input_complex$value, na.rm = TRUE)
total_d
total_j = sum(rnet_joined_df$value_weighted, na.rm = TRUE)
total_j
difference = total_d / total_j
round(1 - total_d / total_j, 3) # New net has 15% more value
rnet_joined_df$value_weighted = rnet_joined_df$value_weighted * difference
# sum(rnet_joined_df$value_weighted, na.rm = 
# TRUE) / sum(rnet_joined_df$length_y, na.rm = TRUE)
# sum(input_complex$value * input_complex$length) / sum(input_complex$length)
rnet_joined_aggregated = rnet_joined_df |>
  group_by(identifier) |>
  summarise(value = sum(value_weighted, na.rm = TRUE) / sum(length_y, na.rm = TRUE))
sum(rnet_joined_aggregated$value, na.rm = TRUE) == sum(input_complex$value, na.rm = TRUE)

rnet_joined_linestrings = left_join(input_simple, rnet_joined_aggregated, by = "identifier")

```

The result is as follows:

```{r}
#| label: joined
rnet_joined_linestrings$length_simple = as.numeric(sf::st_length(rnet_joined_linestrings))
cor(rnet_joined_linestrings$length_simple, rnet_joined_linestrings$length)
sum(rnet_joined_linestrings$value * rnet_joined_linestrings$length, na.rm = TRUE)
sum(input_complex$value * input_complex$length, na.rm = TRUE)

tm_shape(rnet_joined_linestrings) + tm_lines("value")
```

```{r}

```

